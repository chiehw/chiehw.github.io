---
title: 《Effective C++》-5 继承
categories: 程序人生
tags:
  - C++
  - 《Effective C++》
abbrlink: 1070c405
date: 2023-06-10 10:04:17
---
# 条款 32：确定你的 public 继承塑膜出 is-a 关系

## 01 继承的含义是什么？

public inheritance（公开继承）意味着 “is-a” 的关系。

如果你令 class D 以 public 形式继承 class B，你便是告诉 C++ 编译器说，每一个类型为 D 的对象同时也是一个类型为 B 的对象，反之不成立。你的意思是 B 比 D 表现出更一般化的概念，而 D 比 B 表现出更特殊化的概念。你主张 B 对象比 D 表现更一般化的概念，而 D 比 B 表现出更特殊化的概念。你主张 B 对象可派上用场的地方，D 对象一样可以派上用场，此即 Liskov Substitution Principle，因为每一个 D 对象都是一种 B 对象。反之如果你需要一个 D 对象，B 对象无法效劳，因为虽然每个 D 对象都是一个 B 对象，反之并不成立。

## 02 为什么拒绝在运行期检查错误？

在编译期拒绝用户编译，可以更好的避免让用户错误的使用接口。因为好的接口可以防止无效的代码通过编译，而不是只在运行时才能检测出来。

## 03 如何使用 public 继承？

public 继承会导致 base class 对象身上的每件事都可以施行于 derived class 身上，如果不能实现这样的效果，那么这样的继承会导致它们之间的关系不确定。编译器会让你通过编译，但是一如我们所见，这并不保证程序的行为正确。这就像程序员一定学过的：代码通过编译并不代表就可以正常运行。

避免遮掩继承而来的名称。如果遮蔽继承而带来的名称，就会导致 base class 和 derived class 之间的 is-a 关系被破坏

# 条款 33：避免遮掩继承而来的名称

## 01 如果不想继承所有的函数，那该怎么办？

在 public 的继承中，这绝对不可能，因为它违反了 public 继承所暗示的 base 和 derived classes 之间的 is-a 关系。

可以考虑使用 private 继承。私有继承会让基类成为一种单独的类型，对于外界来说 derived classes 并没有继承 base classes，在派生类中，基类的共有函数会编程私有函数，不能被外部访问。

# 条款 34：区分接口继承和实现继承

## 01 virtual 函数和普通函数的区别？

如果一个成员函数在基类中被声明为 virtual，那么它就可以被派生类覆盖，并根据运行时对象的实际类型来动态的调用相关函数。与普通函数不同的是，virtual 函数在运行时决定调用哪个函数，而不是在编译时就决定。

普通函数不能被继承或覆盖，只有虚函数才能被派生类覆盖。

## 02 需要关心 virtual 函数的成本吗？

一个典型的程序有 80% 的执行时间花费在 20% 的代码上，这一法则十分重要，这意味着，平均而言你的函数调用中可以有 80% 是 virtual，而不冲击程序的大体效率。

当你担心是否有能力负担 virtual 函数的成本之前，请先将心力放在那举足轻重的 20% 代码上。

## 03 接口继承和实现继承的区别？

接口继承是指一个类继承了另一个类的接口，即继承了另一个类的公共方法和属性，但没有继承其实现。接口继承的目的是为了实现其多态性，即让不同的类可以实现同样的接口，从而让它们可以替换使用。在接口继承中，一个类可以同时继承多个接口，从而实现多重继承。

实现继承是指一个类继承了另一个类的接口和实现，即继承了另一个类的公共方法和属性，同时也继承了其实现。实现继承的目的是为了代码的复用性，即让一个类可以重用另一个类的视线，从而减少代码的重复。在实现继承中，一个类只能继承一个父类，从而实现单继承。

# 条款 35：考虑 virtual 函数以外的选择

## 01 为什么要使用 private virtual？

**令客户通过 public non-virtual 成员函数之间间接调用 private virtual 函数，称为 non-virtual interface（NVI）手法**。它是 Template Method 设计模式的一种独特表现形式。我把这个 non-virtual 函数称为 virtual 函数的外覆器（Wrapper）。

**NVI 手法的一个优点隐身在上述代码注释“做一些事前工作”和“做一些事后工作”之中**。那些注释用来告诉你当时代码保证在“virtual 函数进行真正工作之前和之后”被调用。这意味着 wrapper 得确保得以在一个virtual 函数被调用之前设定好适当的场景，并在调用结束之后。

事前工作可以包括锁定互斥体 Mutex、制造运转日志记录项（log entry）、验证 class 约束条件、验证函数先决条件等等。事后工作可以包括互斥体解除锁定、验证函数事后条件、再次验证 class 约束条件等等。如果你让客户直接调用 virtual 函数，就没有更好的办法做这些事情。

## 02 什么是策略模式 Strategy？

策略模式是一种行为型设计模式，它允许在运行时动态地改变算法或策略，而无需更改客户端使用的代码。该模式通过将不同的算法封装到独立的类中，并使它们之间相互替换来实现这一点。

## 03 什么是 Template Method 模式？

模版方法模式是一种行为型设计模式，它定义了一个高效的算法框架，将算法的默写步骤延迟到子类中实现。模版方法模式可以提高代码的复用性和可用性，而因为它把算法的公共部分封装在抽象类中，而把算法的具体实现留给子类去完成。

## 04 tr1::function 是什么？

tr1::function 是 C++ 11 标准库中的一个函数对象类，它可以用于封装任意可调用对象（如函数指针、成员函数指针、函数对象等），并支持在运行时动态地进行绑定和解绑定。

tr1::function 可以让我们将函数和函数对象作为参数传递给其他函数，或者存储在容器中，从而实现更加灵活的编程。这样的对象可以持有任何可调用的对象，包括函数指针、函数对象或成员函数指针，只要签名式兼容需求端。所谓兼容，意思是这个可调用物的参数可以被隐式转换。

## 05 传统 Strategy 模式和现有的 Strategy 模式区别？

传统的 Strategy 模式，会将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。也就是主要利用继承来实现策略的替换。顶一个一个抽象的策略接口和一组具体的策略类，每个具体的策略类都实现了策略接口的方法。然后在客户端代码中，我们通过创建具体的策略类的对象来选择不同的算法。（这种方法的缺点在于它需要定义多个策略类，而且客户端代码需要知道所有的策略类，从而导致代码的复杂度和耦合性增加）

现有的 Strategy 模式使用函数指针、函数对象或 Lambda 表达式来实现策略的替换，即定义一个接受函数指针、函数对象或 Lambda 表达式作为参数的函数或类模版，然后在客户端代码中传递不同的函数指针、函数对象或Lambda 表达式来选择不同的算法。

# 条款 36：绝不重新定义继承而来的 non-virtual 函数

## 01 重新定义 non-virtual 函数会怎样？

non-virtual 函数是静态绑定，当使用指针调用函数时，会根据指针的类型来调用不同的函数。但，virtual 函数可以识别指针背后的对象类型（动态绑定）。

# 条款 37：绝不重新定义继承而来的缺省参数值

## 01 为什么不要重新定义缺省参数值？

virtual 函数是动态绑定的，而缺省参数值却是静态绑定的。

```c++
Shape *ps;						// 静态类型是 Shape
Shape *pc = new Circle;			// 静态类型是 Shape
Shape *pr = new Rectangle;		// 静态类型是 Shape
```

无论它们真正指向什么，它们的静态类型都是 Shape*，静态类型和指针类型有关。对象的所谓动态类型则是指目前所指对象的类型。也就是说，动态类型可以表现出一个对象将会有什么行为。pc 的动态类型是 Circle，pr 的动态类型是 Rectangle。ps 没有动态类型。

virtual 函数是动态绑定而来，意思是调用一个 virtual 函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。

# 条款 38：通过复合塑膜出 has-a 或根据某物实现出

## 01 复合和继承的区别？

复合（composition）是类型之间的一种关系，当某种类型的对象内含它种对象时，便是这种关系。public 继承通常表示 is-a 的意义（是一种），复合通常表示 is-implemented-in-term-of（根据某物实现出）

# 条款 39：明智而审慎地使用 private 继承

## 01 private 继承有什么意义？

Private 继承意味着 implemented-in-term-of（根据某物实现出）。如果你让 class D 以 private 形式继承 class B，你的用意是为了采用 class B 内已经备妥的某些特性，而不是因为 B 对象和 D 对象存在有任何观念上的关系。

private 继承纯粹只是一种实现技术（这就是为什么继承一个 private base class 的每样东西在你的 class 都是 private：因为它们都只是实现枝节而已）。Private 继承在软件设计层面上没有意义，其意义只及于软件实现层面。

# 条款 40：明智而审慎地使用多重继承

## 01 菱形继承会导致什么问题？

![image-20230526140025264](https://blog-1256032382.cos.ap-nanjing.myqcloud.com/2023/05/upgit_20230526_1685080825.png)

类 A 派生出类 B 和 类 C，类 D 继承自类 B 和类 C，这时候类 A 中的成员变量和成员函数继承到类 D 中变成两份，一份来自 A->B->D 这条路径，另一份来自 A->C->D 这条路径。

在一个派生类中保留间接基类的多份同名称成员，虽然可以在不同成员变量中存放不同的数据，但大多数情况下是多余的，因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A->B->D 这条路径，还是来自 A->C->D 这条路径。

## 02 虚继承和虚函数的区别？

虚函数用于实现 C++ 中的动态多态性。在 C++ 中，通过使用虚函数，可以在运行时确定调用的函数实现，而不是在编译时确定。这样，就可以根据基类指针或引用调用同名函数时，根据对象实际类型调用对应的函数实现。

虚继承用于解决 C++ 多重继承中的菱形继承问题。在菱形继承中，派生类从多个基类中继承同一个间接基类，导致该间接基类在派生类中存在多个实例，从而引起命名冲突和资源浪费的问题。**通过在基类继承关系中使用虚继承，可以让共同的间接基类在派生类中只有一个实例**，从而避免这些问题。

