---
title: 《Effective C++》-3 封装与设计
categories: 编程杂货铺
tags:
  - C++
  - 《Effective C++》
abbrlink: 58e7fb96
date: 2023-06-10 10:02:55
---


# 条款18：让接口容易被正确使用，不易被误用

## 01 如何实现该条款的内容？

下面是一些常见的错误：

```c++
Data d(30, 3, 1995);
Data d(2, 30, 1995);	// 1. 可能会以错误的参数传参。可以考虑导入新类型解决，还可以顺便检查参数。
Data d(Month(3), Day(30), Year(1995)) 
    
if (a*b = c) ... // 2. 不恰当的行为。该例可以通过 const 修饰 operator * 的返回值来阻止用户的行为。
```

许多时候，**最佳接口的设计原则是先发制人**。常见的方法包括建立新类型、限制类型上的操作、束缚对象的值、以及消除客户的资源管理责任。

# 条款19：设计 class 犹如设计 type

> 这一条款可以直接应用于 class 的设计，所以几乎摘抄全文

你应该带着和 “语言设计者当初设计语言内置类型时”一样的谨慎来研讨 class 的设计。如何设计高效的 class 呢？首先你必须了解你面对的问题，几乎每一个 class 都要求你面对以下提问，而你的回答往往导致你的设计规范：

1. **新 type 的对象应该如何被创建和销毁**？这会影响到你的 class 的构造函数和析构函数以及内存分配函数和释放函数的设计，当然前提是如果你打算撰写他们。
2. **对象的初始化和对象的赋值应该有什么样的差别**？这个答案决定你的构造函数和赋值操作符的行为，以及其间的差异。很重要的是别混淆了“初始化”和赋值，因为他们应用于不同的函数调用。（见条款 4）
3. **新 type 的对象如果被 pass by value，意味着什么**？记住 copy 构造函数用来定义一个 type 的 pass-by-value 该如何实现。
4. **什么是新 type 的“合法值”**？对 class 的成员变量而言，通常只有某些数值集是有效的。那些数值集决定了你的 class 必须维护的约束条件，也就决定了你的成员函数必须进行的错误检查工作。它也影响函数抛出的异常、以及函数异常明细列。
5. **你的新 type 需要配合某个继承体系吗**？如果你继承某些既有的 class，你就受到那些 class 的设计的束缚，特别是受到他们 virtual 或 non-virtual 的影响。如果你允许其他 classes 继承你的 class，那会影响你所声明的函数——尤其是析构函数——是否为 virtual。（见条款 34、 条款 36、条款 7）
6. **你的新 type 需要什么样的转换**？你的 type 生存与其他一海票 types 之间，因而彼此该有转换行为吗？如果你希望类型 T1 之物被隐式转换为 T2 之物，就必须在 class T1 内写一个类型转换函数或在 class T2 内写一个 non-explicit-one-argument 的构造函数，如果你只允许 explicit 构造函数存在，就得写出一个专门负责执行转换的函数。（见条款 15）
7. **什么样的类型操作符和函数对比新 type 而言是合理的**？这个问题的答案取决于你将为你的 class 声明哪些函数。其中某些该是 member 函数，某些则否（见条款 23、25、46）。
8. **什么样的标准函数应该驳回**？那些正是你必须声明 private 者（见条款 6）。
9. **该谁取用新的 type 的成员**？这个提问可以帮你决定哪个成员为 public，哪个为 protected，哪个为 private。这也帮助你决定哪一个 classes 和 functions 应该是 friends，以及将他们嵌入另一个之内是否合理。
10. **什么是新 type 的“未声明接口”**？它对效率、异常安全性以及资源运用提供何种保证？你在这些方面的保证将为你的 class 实现代码加上相应的约束条件。（见条款 29）
11. **你的新 type 有多么一般化**？或许你其实并非定义一个新 type，而是定义一整个 types 家族。果真如此你就不该定义一个新的 class，而是应该定义一个新的 class template。
12. **你真的需要一个新的 type 吗**？如果只是定义新的 derived class 以便于既有的 class 添加机能，那么说不定单纯定义一个或多个 non-member 函数或 templates，能够达到目标。

Class 的设计就是 type 的设计，在定义一个新的 class 之前，请确定你已经考虑了本条款覆盖的所有讨论的主题。

# 条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value

## 01 为什么用 pass by reference to const？

reference 保证了性能。使用引用传递时，没有任何的构造函数和析构函数被调用，只是对原对象的引用，也减小了内存的使用。如果以 by value 的方式传递，并且该对象内部还有其他对象，或是对象继承于其他对象，会极大的增加传递时的消耗。

const 保证安全性。这样就能让调用者知道他们受到保护，函数内绝不会对传入的对象作出任何改变。

## 02 什么时候可以 pass by value？

一般而言，可以 pass by value 的唯一对象就是内置类型和 STL 迭代器和函数对象。至于其他任何东西都请遵守本条款的忠告，尽量以 pass by reference 的方式替换 pass by value。

# 条款 21：必须返回对象时，别妄想返回其 reference

## 01 赋值的成本有多少？

在对象之间搬移数值最直接的办法就是通过赋值。对于许多 types 而言，赋值的成本相当于调用了一个析构函数（用以销毁旧值）加上一个构造函数。

## 02 什么时候必须使用 return by value？

绝不要返回 pointer 或 reference 指向一个 local stack （通常会产生空指针），或是 reference 指向一个 heap-allocated 对象（因为很有可能会造成资源泄露）。

# 条款 22：成员变量声明为 private

## 01 为什么要将成员变量设置为 private？

如果成员变量不是 public，客户唯一能够访问对象的办法就是通过成员函数。如果 public 借口内的每样东西都是函数，客户就不需要打算访问 class 成员时迷惑地试着记住是否该使用小括号。

使用函数而非 public 还可以让你对成员变量的访问的处理更加的精确，你可以实现不准访问、只读访问以及读写访问。如何你使用函数访问成员变量的话，日后还可以更改某个计算替换掉这个成员变量，而 class 客户端不需要做任何修改。

**如果成员变量不是 private，就有无限量的函数可以访问它们，它们也就毫无封装性。**

# 条款 23：宁以 non-member、non-friend 替换 member 函数

## 01 为什么 non-member 更好？

为了更好的封装性。

**non-member、non-friend 函不会增加“能够访问 class 内 private 成文”的函数数量**，也就是说可以获得更好的封装性，我们在修改 class 时能够更少的减少代码的修改。

对于那些习惯于“所有函数都必须定义于class内”的语言（Java）的程序员而言，我们可以令该函数成为类的 static member函数。在 C++ 中，比较自然的做法是让其成为一个 non-member 函数并且位于 class 所在的同一个 namespace 中。

## 02 封装为什么那么强大？

如果某些东西被封装，它就不再可见。愈多东西被封装，愈少人可以看见它。而愈少人看到它，我们就可以有愈大的弹性去改变它，因为我们的改变仅仅可以直接影响看到的改变的那些人事物。因此，愈多东西被封装，我们改变那些东西的能力就愈大。

**它使我们能够改变事物而只影响有限的客户**。

# 条款 24 若所有参数皆需要类型转换，请为此采用 non-member

## 01 如何实现支持交换律的 class？

让 operator * 成为一个non-member函数，并且允许编译器在每个实参身上执行隐式类型转换，也就是在构造函数刻意不使用 explicit。

# 条款 25：考虑写出一个不抛出异常的 swap 函数

## 01 为什么要 using swap？

一旦编译器看到对 swap 的调用，它们便查找适当的 swap 并调用之。C++ 的名称查找法则（name lookup rules）确保将找到 global 作用域或 T 所在的命名空间内的任何 T 专属的 swap。如果 T 是 Widget 并位于命名空间 WidgetStuff 内，编译器会使用“实参取决之查找规则”找出 WidgetStuff 内的 swap。如果没有 T 专属的 swap 存在，编译器就使用 std 内的 swap，这就是 using swap 声明式让 std::swap 在函数内暴露的原因。

## 02 如何让 swap 在更多语境下被调用？

你需要同时在该 class 所在的命名空间写一个 non-member 版本以及一个 std::swap 特化版本。

```c++
namespace std {
    template<>
    void swap<Widget>(Widget &a, Widget &b){
		a.swap(b);
    }
}
```

## 03 如何实现一个高效的 swap？

1. 提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象的值。
2. 在你的 class 或 template 所在的命名空间内提供一个 non-member swap，并令他调用上述的 swap 成员函数。
3. 如果你在编写一个 class（而非 class template），为你的 class 特化 std::swap，并令它调用上述 swap 成员函数。（因为有些人会使用 `std::swap` 来调用 swap）

最后如果你调用 swap，请确定包含一个 using 声明式，以便让 std::swap 在你的函数内曝光可见，然后不加任何 namespace 修饰符，赤裸裸地调用 swap。

## 04 为什么 swap 不能抛出错误？

成员版的 swap 绝不抛出异常。**这一约束只施行于成员版**！！不可施行于非成员版。

因为 swap 缺省版本是以 copy 构造函数和 copy assignment 操作符为基础，而一般情况下两者都允许抛出异常。因此当你写下一个自定义版本的 swap，往往提供的不只是高效置换，而且不抛出异常。一般而言，这两个 swap 特性是连在一起的，因为高效率的 swap 几乎总是对内置类型的操作，而内置类型的操作绝不会抛出