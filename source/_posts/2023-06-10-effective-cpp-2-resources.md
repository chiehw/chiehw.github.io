---
title: 《Effective C++》-2 资源管理
categories: 程序人生
tags:
  - C++
  - 《Effective C++》
abbrlink: b1c7d8ef
date: 2023-06-10 10:02:01
---

# 条款13：以对象管理资源

## 01 资源管理的核心是什么？

**获取资源后立即放进管理对象**。有时候获得得资源被拿来赋值某个管理对象，但无论哪一种做法，每一笔资源都在获得得同时立即被放进管理对象中。如 createInvestment 应该将返回值存储在智能指针对象内部，而不是让用户自己去封装。

**管理对象运用析构函数确保资源被释放**。无论控制流如何离开区块，一旦对象被销毁其析构函数自然会被自动调用，于是资源被释放。如果资源释放动作可能导致抛出异常，可以考虑利用普通函数来处理这种容易报错得操作。

## 02 auto_ptr 如何防止多个指针指向同一个对象？

若通过 copy 构造函数或 copy assignment 操作符复制他们，它们会变成 null，而复制所得得指针将取得资源得唯一拥有权。类似 rust 中得复制，这样可以让对象在同一时间只有一个所有者。

STL 容器要求其元素需要发挥正常的复制行为，因此这些容器不能使用 auto_ptr，只能使用引用计数型的智能指针（Reference-Counting Smart Pointer，RCSP）。

## 03 为什么不要将数组放在智能指针中？

auto_ptr 和 shared_ptr 两者都在其析构函数内做 delete 而不是 delete[]。因为 vector 和 string 几乎总是可以取代动态分配而得的数组。

## 04 unique_ptr 修复了 auto_ptr 的什么问题？

1. 所有权转移的语义不够清晰：auto_ptr 的所有权转移语义有时会导致不太明显的行为，比如复制、移动和赋值操作并不总是按预期方式工作。
2. 不可传递：auto_ptr **不能被安全的放入标准容器或作为函数参数**（因为复制不能保证正常），unique_ptr 通过移动构造函数和移动复制运算符解决了这个问题。
3. **不支持自定义删除器**：auto_ptr没有提供一种简单的方式来自定义删除其，因此它智能用于管理动态分配的单个对象。unique_ptr 允许用户自定义删除其，这使得它可以用于管理动态分配的数组、动态分配的对象和其他资源。

# 条款14：在资源管理类中小心copying行为

## 01 当一个 RAII 对象被复制，会发生什么？

- **禁止复制**。许多时候允许 RAII 赋值并不合理。只需要将拷贝操作（拷贝赋值、拷贝构造）申明为 private 即可。如 Mutex
- **对底层资源使用“引用技术”**。有时候我们希望保有资源，直到它的最后一个使用者被销毁。这种情况就需要对资源进行引用技术——shared_ptr。如对象。
- **复制底部资源**。复制资源管理对象时，进行的是深度拷贝。例如 heap 内存。
- **转移资源的拥有权**。某些罕见场合下你可能希望确保永远只有一个 RAII 对象指向一个资源，即使 RAII 对象被复制依然如此。如 unique_ptr。

# 条款15：在资源管理类中提供对原始资源的访问

## 01 RAII 如何访问原始资源？

RAII class 并不是为了封装某物而存在的，它们的存在是为了一个特殊的行为——资源释放——一定会发生，因此 RAII class 含有返回原始资源的函数很正常。通常有两种方式：显示转换比较安全，隐式转换对客户比较方便。

**显式转换**：shared_ptr 和 auto_ptr 都提供了 get 函数成员，用来执行显示转换（也就是返回指针内部的原始指针），shared_ptr 和 auto_ptr 也重载了指针取值（pointer dereferencing）和操作符（operator->和operator*）。

**隐式转换**：使用类型转换运算符（Type Conversion Operator），即类似`operator FontHandle() const`。需要注意的是，类型转换运算符应该谨慎使用，因为它们可能会导致意外的类型转换和类型错误。因此，应该旨在确实需要自定义类型转换时才使用。

更推荐显式转换，因为最佳实践是“让接口容易被使用，不容易被误用”。

# 条款16：成对使用new和delete要采取相同的形式

# 条款17：以独立语句将 newed 对象放入智能指针中

## 01 为什么需要用独立的语句？

以独立语句将 newed 对象存储于只能指针内，如果不这样做，一旦异常被抛出，可能导致难以察觉的资源泄露。

```c++
processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority());
// 正确写法
shared_ptr<Widget> pw(new Widget);
processWidget(pw, priority());
```

上面这个语句要做 3 件事：

1. 执行 new Widget
2. 调用 priority
3. 调用 shared_ptr 的构造函数。

这三件事无法确定 priority 和 new Widiget 的次序，**如果 priority 在 new Widget 和 shared_ptr 的构造函数之间，priority 在调用时发生了异常，那么 new Widget 的指针就无法放入 shared_ptr，从而会进一步导致资源泄露**。

