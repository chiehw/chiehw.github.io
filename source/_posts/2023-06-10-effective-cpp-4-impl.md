---
title: 《Effective C++》-4 实现功能
categories: 程序人生
tags:
  - C++
  - 《Effective C++》
abbrlink: 175f897
date: 2023-06-10 10:03:41
---
# 条款 26：尽可能延后变量定义式的出现时间

## 01 为什么要延后变量的定义？

你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它的初值实参为止。如果这样，不仅能够避免析构和构造非必要对象，还可以避免无意义的 default 构造行为。

更深一层说，以“具明显意义之初值”将变量初始化，还可以附带说明变量的目的。

# 条款 27：尽量少做转型动作

## 01 C++有哪些新式转型？

- const_cast：通常被用来将对象的常量性转除（cast away the constness）。它也是唯一有此能力的 C++-style 转型操作符。
- dynamic_cast：主要用来执行向下转型（Safe downcasting），也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。
- reinterpret_cast：意图执行低级转型，实际动作可能取决于编译器，这也表示它不可移植。例如将一个 pointer to int 转型为 int。这一类转型在低级代码以外很少见。
- static_cast：用来强迫隐式转换（implicit conversions），例如将 non-const 对象转为 const 对象，或将 int 转为 double 等等。它也可以用来执行上述多种转换的反向转换，如将 void * 指针转为 typed 指针，将 pointer to base 转为 pointer derived。但它无法将 const 转为 non-const。

## 02 为什么不要操作对象的指针？

对象的布局方式和他们的地址计算方式随编译器的不同而不同，这意味着“由于知道对象如何布局”而设计的转型，在某一平台可能行得通，在其他平台并不一定行得通。

## 03 什么时候使用 dynamic_cast？

通常是因为你想在一个你认定为 derived class 对象身上执行 derived class 操作函数，但你手上却只有一个指向 base 的 pointer 或 reference，你只能靠他们来处理对象。

大多数时候，“使用类型安全的容器”或“将 virtual 函数往继承体系上方移动” 都可以作为 dynamic_cast 的替代方案。在注重效率的代码中避免使用 dynamic_cast。

# 条款 28：避免返回 handles 指向对象内部成分

## 01 什么是 handles？

Reference、指针和迭代器统统都是所谓的 handles（号码牌，用来取得某个对象）。

# 条款 29：为“异常安全”而努力是值得的

## 01 下面的互斥锁哪里有问题？

```c++
void PrettyMemu(std::istream &imgSrc){
    lock(&mutex);
    delete bgImage;
    ++imageChanges;
    bgImage = new Image(imgSrc);
    unlock(&mutex);
}
```

 一旦 new Image 导致异常，对 unlock 的调用就不会执行，于是互斥锁就永远被把持住。这里可以考虑导入 Lock class，它可以获得互斥锁，并确保它稍后被释放。

## 02 异常安全性的函数有哪些特点？

**不泄露任何资源**：例如上锁的 Mutex，在线程出现异常时，依然能正常释放 Mutex。

**不允许任何数据败坏**：假设有一个操作是写入数据，如果写入失败，那么不应该允许读取写入失败的数据（也就是记录不能 + 1）。

## 03 pimpl 是什么？

pimpl 意思为“具体实现的指针”（Pointer to Implementation），它通过一个私有的成员指针，将指针所指向的类的内部实现数据进行隐藏，降低耦合性，并有着“编译防火墙”的名头。

## 04 异常安全函数的三个保证？

**基本承诺**：如果异常被抛出，程序内的任何事物仍然保持在有效的状态下。没有任何对象或数据结构因此会败坏，所有对象都处于一种内部前后一致的状态（如所有 class 约束条件都继续获得满足）。

**强烈保证**：如果异常被抛出，程序状态不改变。调用这样的函数需要这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回复到调用函数之前的状态。

**不抛掷（nothrow）保证**：承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于内置类型（int、指针）身上的所有操作都提供 nothrow 保证。

## 05 如何让代码具备异常安全性？

首先是以对象管理资源，那可阻止资源泄露。然后是挑选三个异常安全保证中某一个实施于你写的每一个函数上。你应该挑选现实可施作条件下的最强烈等级，只有当你的函数调用了传统代码，才别无选择地将它设为“无任何保证”。

将你的决定写成文档，这一来是你的函数用户着想，而来是为将来的维护者着想。函数的异常安全性保证是其可见接口的一部分，所以你应该慎重选择，就像选择函数接口的其他任何部分一样。

# 条款 30：透彻了解 inline 的里里外外

## 01 使用 inline 的缺点？

在一台内存有限的机器上，过度热衷 inlineing 会导致程序体积过大。即使拥有虚内存，inline 造成的代码膨胀会导致额外的换页行为，降低指令高速缓冲装置的击中率，以及伴随这些而来的效率的损失。

## 02 为什么 virtual 不能 inline？

inline 是个申请，编译器可加以忽略，大部分编译器拒绝将太过负责的函数 inline。

virtual 意味着“等待，直到运行期才确定调用哪个函数”，而 inline 意味着执行前先将调用动作替换为被调用函数的本体，如果编译器不知道该调用哪个函数，就无法将函数本体 inline。

## 03 如何正确的提高程序的效率？

平均而言，一个程序往往将 80% 的执行时间花费在 20% 的代码上，这是一个重要的法则，因为它提醒你，作为一个软件开发者，你的目标是找出这可以有效增进程序整体 20% 的代码，然后将它 inline 或竭尽所能的为它瘦身。

除非你选对目标，否则一切都是虚功。

# 条款 31：将文件间的编译依存关系降至最低

## 01 为什么要减少编译的依存关系？

当编译器看到变量的定义式，它必须知道分配多少内存，编译器获取这项信息的唯一办法就是询问 class 定义式。然而如果 class 定义式可以合法地不列出实现细目，编译器如何知道该分配多少内存？

C++ 的源文件和其函数的头文件之间形成了一钟编译依存关系（compilation dependency）。如果这些头文件中含有任何一个被改变，或这些头文件所依赖的其他头文件有任何改变，那么每一个含入该头文件的 class 文件就得重新编译。这样的连串编译依存关系会对许多项目造成难以形容的灾难。

## 02 如何减少编译的依存关系？

因为当编译器看到一个新类型的定义式时，它必须知道需要分配多少内存才能持有该对象，而这正是编译依存关系的关键。即分离的关键在于 **“声明的依存性” 替换 “定义的依存性”**，现实中让头文件尽可能自我满足，万一做不到

可以利用 **pimpl idiom** 来将对象隐藏在指针之后，最终做到接口与实现分离（Handle class）。在 Handle class 身上，成员函数必须通过 implementation pointer 取得对象数据。那会为每一次访问增加一层间接性。而每一个对象消耗的内存数量必须增加 implementaion pointer 的大小。最后 implementation pointer 必须初始化，指向一个动态分配而来的 implementation object，所以你受因内存分配而带来的开销，以及遭遇 bad_alloc 异常的可能。

还可以利用 **Interface Class**，由于每一个函数都是 virtual，所以你必须为每次函数调用付出一个间接跳跃。此外 Interface class 派生的对象必须内涵一个 vptr，这个指针可能会增加存放对象所需的内存数量——实际取决于这个对象除了 Interface Class 之外是否还有其他 virtual 函数来源。

## 03 有哪些接口与实现的分离策略？

1. **如果使用 object reference 或 object pointer 可以完成任务，就不要使用 objects**。你可以只靠一个类型声明式就定义出指定该类型的 references 和 pointers；但是如果定义某个类型的 object，就需要用到该类型的定义式。
2. **如果能够，尽量以 class 声明式替换定义式**。注意，当你声明一个函数而它用到某个 class 时，你并不需要该 class 的定义，纵使函数以 by value 方式传递该类型的参数。
3. **为声明式和定义式提供不同的头文件**。为了促进严守上述准则，需要两个头文件，一个用于声明式，一个用于定义式。当然这些文件必须保持一致性，如果有个声明式被改变了，两个文件都得改变。因此程序库客户应该总是 #include 一个声明文件而非前置声明若干函数，程序库作者也应该提供这两个头文件。

## 04 string 不是一个 class 吗？

string 是一个类（class），而且是模板类（template class），它被定义为 `basic_string<char>` 的一个实例化版本。

string 并不是一个独立的类，而是基于 basic_string 这个模板类派生出来的一个特化版本，在编译时会将 `basic_string<char>` 替换成 string，这样就可以用 string 类型来表示字符串了。

## 05 什么是 bad_alloc？

bad_alloc 是 C++ 标准库中的一个异常类，用于表示内存分配失败的情况。当使用 new 运算或者其他内存分配函数申请内存时，如果操作系统无法分配所需的内存空间，就会抛出 bad_alloc 异常。

bad_alloc 异常通常是由于内存不足或者内存碎片化导致的。在程序中，如果需要申请大量的内存，就需要注意处理 bad_alloc 异常，以避免程序崩溃或者出现不可预测的错误。

## 06 C++ 和 Java Interface class 的区别？

C++ 的 Interface Class 并不需要负担 Java 和 .NET 的 Interface 所需负担的责任。

例如，Java 不允许 Interface 内实现成员变量和成员函数，但 C++ 不禁止这两样东西。C++ 这种更为强大的弹性尤其作用，non-virtual 函数的视线对继承体系内所有 class 都应该相同。