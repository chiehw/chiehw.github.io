---
title: 《精通 LevelDB》-2 源码初识
categories: 编程杂货铺
tags:
  - 存储引擎
  - 《精通 LevelDB》
abbrlink: b19d156f
date: 2023-06-10 10:28:18
---

> 目前我的思路是，根据 LevelDB 的源码来尝试自己编写源码（实在不会就抄，抄完再理解）。这样的思路很容易迷路，无法识别源码中的重点，无法理清其设计思路的精髓，耗费时间长但是收益低。
>
> 需要调整阅读源码的策略，所以没有读完所有源码。后续应该会尝试“**根据理论设计 LevelDB 源码结构，阅读源码验证思想**”

# 第1部分：Arena

推荐先实现 AtomicPoint，因为 Arena 依赖于 AtomicPoint。Arena 整体难度不大，但能帮助我们了解一个内存池的大致工作流程、内存对齐的计算方法。

实现完 Arena 之后可以实现 test_harness，用来测试 Arena 是否能正常运行。

## 01 为什么 alloc_bytes_remaining_ 不是使用大小？

Arena 是内存池，alloc_bytes_remaining 表示当前块的剩余的大小，会一直改变。memory_usage 代表内存池已使用的大小。

## 02 AtomicPointer 指针作用？

AtomicPointer 是一种可以实现原子读写操作的指针数据类型，该类型可以用于实现无锁的数据存储操作。

Atomic 是原子，从物理学来看，所谓原子就是最小的物质，不可以再对其进行分割。而这里的原子操作的概念主要指进行某项操作时，执行过程不会被打断。在多线程中，如果可以将一个操作定义为原子操作，那么就无需为这个操作加锁，以实现对其操作变量的保护。

## 03 什么是内存屏障？

在多核处理器中，每个核心都有自己的缓存，因此在多核系统中，不同核心之间的缓存同步和内存同步都是非常重要的，内存屏障就是用来保证不同核心之间缓存同步和内存同步的。

内存屏障可以用于实现一些高级同步操作，比如锁和原子操作。在多线程程序中，使用内存屏障可以保障线程之间的操作顺序和时序正确，从而避免出现数据竞争和其他并发问题。

## 04 如何实现内存屏障？

```c++
__asm__ __volatile__("" : : : "memory");
```

`__asm__` 是 GCC 编译器提供的一个关键字，用于嵌入汇编代码到 C/C++ 代码中。它的作用是告诉编译器将括号中的代码插入到编译后的程序中，并且在生成可执行程序的过程中不再对该部分进行优化。

`__volatile__` 关键字表示这个汇编语句是 volatile 操作，即不能被编译器优化掉。另外，使用了 memory 语句，表示**这个汇编语句会修改内存**，从而告诉编译器需要进行内存屏障操作。

## 05 explicit 作用？

explicit 关键字可以用于将构造函数声明为显式构造函数，这意味着该构造函数只能显示调用，而不能隐式地进行类型转换。具体来说，如果没有 explicit 关键字，那么构造函数可以被隐式调用。从而允许将 void * 类型的指针隐式转换为 AtomicPointer 类型的对象。

## 06 内存屏障的作用？

内存屏障通常存在两种操作：Store、Load。Store 方法可以保障写操作之前的所有内存读写不会重排到这条写操作之后去执行。Load 方法可以保障该方法之后的所有内存读写不会重排到 Load 之前执行。

## 07 为什么需要 Load 和 Store？

在现代计算机中，CPU 为了提高程序的执行效率，通常会采用乱序执行和指令重排等技术，将多个指令在不影响程序结果的前提下进行重排和优化。

指令重拍可能会导致内存访问顺序发生改变，如果在多线程中，存在多个线程对共享变量的访问，指令重排可能会导致多个线程之间的读写操作顺序发生变化，从而发生数据竞争和线程安全问题。

## 08 `reinterpret_cast<void *>` 作用？

可以将指针或整数类型的值转换成一个不特定类型的指针，也就是 void 类型的指针。这个指针不指向特定的类型或对象，因此它可以用于指向任何类型的对象或数据。

## 09 如何计算 Arena 的内存使用量？

```c++
char *Arena::AllocateNewBlock(size_t block_bytes)
{
    char *result = new char[block_bytes];
    blocks_.push_back(result);
    memory_usage_.NoBarrier_Store(
        reinterpret_cast<void *>(MemoryUsage() + block_bytes + sizeof(char *)));
    return result;
}
```

MemoryUsage() 会读取 memory_usage 的值，这个值是用来记录当前的使用量的，而内存的使用量由 AllocateNewBlock 函数更新。

可以看出 Arena 的内存使用量包括申请的字节数、blocks_ 数组的大小，其中 `sizeof(char*)` 就是增加的 blocks_ 大小。

## 10 Arena 中各个成员变量的作用？

成员变量 blocks_ 是 char * 类型的 vector 动态数组，数组的每一个元素均保存一个 char 类型的指针地址。这些指针地址指向堆空间中预分配的一个大的内存块，称之为 Block。一般而言，Block 为固定大小的内存块，LevelDB 中默认的 Block 的大小为 4096 B，即 4 KB。当 Block 存满时，则需要重新申请新的 Block。

成员变量 alloc_ptr 也是一个 char* 类型的指针，总是指向当前最新的 Block 的空闲内存空间的起始地址。成员变量 alloc_bytes_remaining 表示 Block 所剩余的空闲空间大小。

## 11 Arena 内存的分配过程？

如果申请的内存在当前块可以分配，那就直接分配。如果不能直接分配，那么进入下一步（申请新的块）。

新的块大小取决于申请的内存的大小 bytes，如果 bytes > 1/4 的 block，那么就直接申请，如果小于，那就申请一个 4096 的 Block。

![ArenaMemoryAllocate.drawio](https://blog-1256032382.cos.ap-nanjing.myqcloud.com/2023/05/upgit_20230507_1683438032.png)

## 12 如何判断某个数字是不是 2 的整数次幂？

```c++
assert(align & (align - 1) == 0);
```

如果这个结果为 0，则说明 align 是 2 的幂次方。

首先，假设 align 是一个 2 的幂次方，即 align = 2^n，其中一个是非负数，。那么 align-1 的二进制表示中，最低的 n 位都是 1，其他位都是 0。align 的二进制表示中最低的 n 位都是 0，这意味着 align & (align - 1) 按位与运算的结果是 0.

## 13 如何求内存的偏移量？

```c++
size_t current_mod = reinterpret_cast<intptr_t>(alloc_ptr_) & (align - 1);
```

假设 align 等于 8，那么 7 的二进制表示位 111，则该运算采用位的操作将返回 alloc_ptr 的最后 3 位比特位，而这 3 个比特位表示即 alloc_ptr 对  align 取模后的结果。

> 取模是一种特殊的与运算。

## 14 new 和 malloc 的关系？

new 和 malloc 都是用于动态分配内存的函数，但是 new 适用于 C++，可以自动计算内存大小和调用对象的构造函数，而 malloc 适用于 C 语言，需要手动计算内存大小和进行类型转换，不会调用对对象的构造函数。

## 15 strstr 函数作用？

用于一个字符串查找另一个字符串第一次出现位置。

## 16 Arena 作用？

- 避免频繁内存分配和释放。LevelDB 中有很多内存分配，使用 Arena 可以通过单次大块内存分配减少分配和释放的开销。
- 内存碎片减少。使用 Arena 可以保证连续的内存空间分配给不同 Key/Value 避免内存碎片。这样有利于复合操作。
- 简化内存回收。只需要回收整个 Arena 的内存空间，而不是逐个 Key/Value 进行回收，这减少了回收的操作开销。

# 第2部分：测试

## 01 为什么 TCONCAT 类需要 Run 和 RunIt 两个函数？

RunIt 是 static 函数，也就是不需要实例化也可以调用该函数，而 Run 函数是公共的成员函数（并且需要用户自己实现）。RunIt 会被注册到 tests 中，然后由 RunIt 来调用 TONCAT 类中的 Run 函数。

RunIt 会先实例化 TONCAT 类，再调用 Run 函数。

## 02 Makefile 中的 ?= 含义是什么？ 

在 Makefile 中，?= 表示**只有在该变量没有被赋值时才会进行赋值**。这种方式使得用户可以通过在命令行或者其他 Makefile 定义变量来修改编译器选项。

## 03 := 和 = 的区别？

= 是 Makefile 中最常用的赋值操作符，它表示将右侧的表达式的值赋给左侧的变量。

= 和 := 之间的主要区别在于变量定义的方式和展开时机。使用 = 定义的变量是动态的，只有使用时才会被展开，而 := 定义的变量是静态的，只有在定义时才会被展开。

## 04 .PHONY 是什么？

.PHONY 是一个特殊的目标，用于声明一组伪目标，这些伪目标不对应任何时机的文件只是用于执行特定的操作或命令。.PHONY 通常用于定义一组常用的操作，如 clean、install、test 等。

## 05 .o 文件后缀是什么？

.o 文件是编译器在编译源代码时生成的中间文件，也称为目标文件。在 Unix 和类 Unix 系统中，.o 文件是重定向文件的一种形式，可以用于链接时将目标文件合并成可执行文件或动态库。

在编译源代码时，通常会将每个源文件编译成一个 .o 文件，然后将所有的 .o 文件连接成一个可执行的文件或动态库。这种方式可以提高编译速度，因为只需要重新编译修改过的源文件，而不需要重新编译整个项目。

## 06 .o 和 .a 的区别？

.o 文件是单个源文件的编译结果，包含编译后的目标代码和一些元数据，例如符号表和重定位表。.o 文件通常用于构建可执行文件或动态库时的中间文件。

.a 文件时静态文件的一种格式，是多个 .o 文件打包后的要给归档文件。.a 文件中包含多个 .o 文件的机器代码和元数据，方便在链接时使用。

## 07 Arena arena 和 Arena arena()的区别

前者定义了一个名为 arena 的 Arena 对象，后者定义了一个名为 arena 的函数，该函数不接受任何参数并返回 Arena 对象。

# 第3部分：Log write

## 01 Slice 和 string 的区别？

Slice 对数据字节的大小没有限制，其内部采用了一个 const char* 的常量指针存储数据。

Slice 不能修改，如果作为函数的返回值，只需要返回长度和指针，而不需要复制长度较长的 key 和 value。此外，Slice 不以 `\0` 作为字符的终止符，可以存储 `\0` 的数据。

## 02 什么是 CRC 算法？

CRC 算法是一种错误检测码计数，它用于检测数据传输或存储过程中可能出现的错误。

CRC 校验码的生成过程是通过在原始数据的末尾添加一些冗余数据，然后计算这些数据的检验码，最终将校验码附加在原始数据后面传输或者存储，接收方在接收数据后重新计算校验码，检查是否与接收到的校验码一致来判断数据是否发生了错误。

## 03 为什么 CRC 使用异或？

异或运算是可逆运算，即 a^b^b = a，这意味着我们可以使用相同的计算方法来计算校验码和校验校验码。

## 04 CRC 为什么需要使用 table 数组？

CRC 校验码的计算涉及大量的位运算，如果每次计算都进行位运算会导致计算效率非常低下，为了提高计算效率，我们可以预先计算一些 CRC 校验码，并将这些数据的 CRC 校验码保存在一个预处理表格中。在后续 CRC 计算过程中，可以直接查表获取 CRC 校验码，避免重复计算，从而提高计算效率。

## 05 (((pval + 3) >> 2) << 2) 的原理？

这段代码的作用是将一个指针值向上舍入到最近 4 字节对齐地址。

具体来说，首先将指针值 pval 加上三，相当于将其向上舍入到最近的 4 的倍数。然后将结果向右移动两位，相当于除以 4，将指针转换为以 4 哥字节为单位的整数个数，。最后将结果左移两位，想到关于将其乘以 4，将以整数个数表示的指针转换为以字节为单位的指针地址。

## 06 为什么 LevelDB 的 CRC 难以理解？

在 LevelDB 中的 CRC32 实现中，没有使用生成式多项式，而是使用了一种表格加速算法，这种算法是通过预先计算一个查找表来加速计算过程。

这种实现方式相对于生成式多项式的方式，在计算速度和内存占用都有一定的优势。

## 07 纯虚函数和虚函数的区别？

在 C++ 中，虚函数是一种可以被覆盖的函数，允许在子类中重新定义该函数。而纯虚函数是一种没有实现的虚函数，需要在子类中被重新定义才能使用。

包含纯虚函数的类是不能直接实例化的，只能作为基类被继承使用。

## 08 File 操作中的 Flush 和 Sync 的区别？

下图展示了数据内容保存到磁盘的整个过程：

![image-20230509165048800](https://blog-1256032382.cos.ap-nanjing.myqcloud.com/2023/05/upgit_20230509_1683622248.png)

程序缓冲区中的数据并不是直接保存到磁盘中，而是要先后经过 Clib 缓冲区、内核缓冲区，才最终到磁盘。fwrite 的本质是将需要的数据写入到 Clib 缓冲区；**fflush 则是将 Clib 缓冲区的数据内容写入到内核缓冲区。fsync 或 fdatasync 主要是将内核缓冲区的数据内容写入到磁盘中**。

LevelDB 本身就是一个嵌入式的存储库，而存储库的首要要求就是要保证数据的可靠性，因而 WritableFile 类封装了 Flush 与 Sync 借口，而弥补单纯的 Append 写入操作的不足。

## 09 errno 是什么？

errno 是一个全局的错误变量，它被定义在 error.h 头文件中，在C和C++中，当发生系统调用、库函数或操作系统本身的错误时，这些函数通常会设置 errno 变量来指示错误类型。

一旦 errno 变量被设置，它可以被许多函数检查以确定最近的错误类型。通常情况下，errno 变量的值为 0，这表示没有发生错误码，以指示错误的类型。

## 10 strchr 函数

strchr 函数是 C 语言中的一个字符串处理函数，它用于在一个字符串中查找指定字符的第一个出现的位置，并返回该位置的指针。

## 11 static 用于普通函数有什么用？

无论在 C 还是 C++ 中，使用 static 关键字定义的函数都是静态函数。静态函数只能在当前源文件中访问，不能被其他源文件访问。这通常用于实现私有或内部函数，以避免它们被外部文件访问。

## 12 struct 和 class 的区别？

在 C++ 中，struct 和 class 的主要区别在于默认的访问控制。默认情况下，struct 的成员时公共的，而 class 的成员是私有的。除此之外，它们的语法和功能基本相同。

struct 通常表示用于纯数据结构，即只包含数据而没有行为的类型，而 class 则用于表示具有具体行为和状态的类型。

## 13 friend class 作用？

friend class 是 C++ 中的一种访问控制方式，它可以让一个类的成员函数或其他类访问另一个类的私有成员。当一个类被声明为另一个类的友元类时，它就可以访问该类的私有成员，而不受访问控制规则的限制。

# 第 4 部分：多线程

## 01 abort 函数作用？

abort 函数是 C++ 标准库中的一个函数，用于使程序异常终止。abort 函数会向操作系统发送一个 SIGABRT 信号，这个信号会导致程序立即停止执行，并在控制台输出错误信息。

abort 函数不同于 C++ 的 throw 关键字，throw 关键字用于抛出异常并进行异常处理，而 abort 函数直接终止执行，不会进行异常处理。因此，在编写程序时，应该根据实际情况选择使用 throw 还是 abort 函数。

## 02 ConVar 和 Mutex 的区别和联系？

ConVer 和 Mutex 的区别在于它们的设计目的和应用场景。ConVer 用于线程间的同步和通信，而 Mutex 用于防止多个线程同时访问共享资源。

ConVer 是条件变量的缩写，它是一种线程间通信的机制。它允许一个线程等待另一个线程的特定条件，而不需要浪费 CPU 时间进行轮训。在实现中，一个线程可以等待一个条件变量，直到另一个线程通知该条件变量被满足，然后该线程才会被唤醒并执行相应的操作。因此，ConVer 通常用于线程之间同步以及解决消费者和生产者问题。

ConVar 可以由 Mutex 和 pthread_cond_v 实现。

## 03 ConVar 怎么使用？

ConVar 总共有 3 个接口：Wait、Signal、SignalAll。

- Wait 用于等待条件变量被满足。调用这个函数将会阻塞当前线程，直到另一个线程调用 Signal 或者 SignalAll 函数发送唤醒信号。
- Signal：发送唤醒信号，用于唤醒一个等待中的线程。如果有多个线程在等待条件变量，那么只会唤醒其中一个线程。
- SignalAll：广播唤醒信号函数，用于唤醒所有等待中的线程。这个函数将会唤醒所有在等待条件变量的线程。

# 第 5 部分：Env

> 操作环境抽象接口

## 01 Env 是如何对操作系统接口进行封装的？

Env 是一个具有纯虚函数的抽象类，一般只用于接口定义，不能进行实例化。Env 作为抽象类，有 3 个派生子类：PosixEnv、InMemoryEnv 和 EnvWrapper

![image-20230511133028372](https://blog-1256032382.cos.ap-nanjing.myqcloud.com/2023/05/upgit_20230511_1683783028.png)

default_env 提供了一个 Env 类实例的全局访问点，而 initDefaultEnv 方法的作用是对 default_env 变量进行初始化操作。Default 函数通过 pthread_once  的一次性线程初始化，实现在整个生命周期中该方法只能调用一次，即 default_env 只会进行一次实例化操作，从而实现一种线程安全的单例模式。

## 02 pthread_once 作用？

pthread_once_t 是一个类型，用于存储一次性初始化的状态，它是一个非常简单的类型，只有一个整型变量 once_control，用于存储一次性初始化的状态。pthread_once_t 的定义如下：

```c++
typedef volatile int pthread_once_t;
```

**pthread_once 函数用于执行一次性初始化**。它接受两个参数：一个指向 pthread_once_t 类型的指针，用于存储一次性初始化的状态，而是一个指针函数，用于执行一次初始化的代码。pthread_once 函数保证一次性初始化的代码只会执行一次，即使多个线程调用这个函数也是安全的。

**pthread_once 函数保证在多线程环境下只执行一次回调函数**。当多个线程同时进入 pthread_once 函数时，只有一个线程会执行回调函数，其他线程会等待该线程执行完毕后继续执行。

# 第 6 部分：Write

## 01 DBImpl::Write 的基本流程是怎样的？

1. 将 WriteBatch 封装到 Writer 对象中，并插入到 writers_ 队列中等待执行。Writer 对象包含了 WriteBatch 的操作，同时也包含了任务的状态（是否完成、需要同步）。
2. 使用 DBImpl 的 mutex_ 来设置临界区域、初始化 Writer 对象的条件变量 cv。利用条件变量 cv 触发线程的 wait，等待队列前面的 Writer 执行完毕。
3. 调用 MakeRoomForWrite 函数来预先分配相应的内存空间。
4. 调用 BuildBatchGroup 合并写入操作。WriteBatch 对象被合并成一个更大的 WriteBatch 对象时，其中序列号会被更新。新的 WriteBatch 对象的序列号会设置为合并前最后一个 WriteBatch 对象序列号加一。假设 Writer 的序号是  2，然后合并了 1。

## 02 为什么 sync 的操作不能合并？

同步写入是一种需要等待磁盘刷写完成的写入操作，相较于异步写入会更加耗时。如果一个写入批次中即包含同步写入，又包含异步写入，那么在写入批次被提交到磁盘之前，需要等待所有同步写入都完成，这可能会导致整个写入批次的提交时间变长，从而影响磁盘的写入性能。