---
title: 《算法 第4版》-排序
date: 2023-04-28 19:33:06
categories: 算法
---


# 第1章：基础



## 01 背包有什么用？

背包是一种不支持从中删除元素的集合元素——它的目的就是帮助收集元素并迭代所有收集到的元素。迭代顺序不确定且与用例无关。

背包常见的应用：

- 搜索：在搜索过程中，背包可以用于存储随机生成的样本数据。
- 数值计算：背包可以用于存储随机生成的样本数据。

许多编程语言没有针对背包这种数据结构提供专门的实现，因为背包是非常简单的数据结构，可以通过其他数据结构来轻松实现。

## 02 Dijkstra 的双栈表达式的优缺点

- 优点：展示了一种重要的计算模型——将一个字符串解释为一段程序并执行该程序得到结果、简单。
- 缺点：无法区分加法和乘法的优先级，必须用括号来保证优先级。

## 03 C++ 的 Vector 会缩容吗？

- C++11 之前，vector 不会自动缩容，除非显式调用 shrink_to_fit 方法。
- C++ 11 之后，vector 可以自动缩小容量。当 vector 的 size 变得比 capacity 的一半还要小时，就会自动缩容。

## 04 如何学习数据结构？

- **定义 API**：分析 API 的设计。
- 根据特定的场景开发用例代码。
- 描述一种数据结构（一组值的表示），并在数据结构中定义变量。
- 描述算法（实现算法）。
- 分析算法的性能特点。

## 05 为什么坚持使用窄接口？

为一个单独的 Collection 数据结构实现添加元素、删除最近插入的元素、删除最早插入的元素、删除随机元素等等其他我们可能的方法，这样我们就能在一个类中实现所有这些方法并可以用于各种实例。这样的作法叫做**宽接口**。

使用窄接口的原因：

- **API 是设计高效算法和数据结构的起点**。
- 无法保证高效的实现这些所有方法。
- **限制用例的行为，使用例代码更加易懂**。



## 06 常见的算法复杂度分类

![image-20230418230524970](https://blog-1256032382.cos.ap-nanjing.myqcloud.com/2023/04/upgit_20230418_1681830325.png)



## 07 编程的首要任务是什么？

**写出清晰正确的代码**。

在编程领域中，最常见的错误或许就是过于关注程序的性能。你的首要任务应该是写出清晰正确的代码。为了提高运行速度而修改程序的事最好留给专家来做。C.A.R.Hoare（快速排序的发明人）曾将这种想法总结为：“不成熟的优化是所有罪恶之源”。

当然也不能完全忽略程序的性能。当我们处理大规模问题是，通常除了寻找更好的泛之外，我们别无选择。

# 第2章：排序

## 01 为什么不要看网上的题解？

网上的题解品质差异很大，不利于学习，总是看劣质的资料容易让自己养成坏毛病（写代码不考虑周全）。同样的题目，书上的代码简洁清晰，网上的代码复杂多样。这些代码做了很多无用功，看这些内容很浪费时间。

在《剑指 Offer》的 109 页，给出了 [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/) 的答案，我们在网上看别人的题解可能也会看到这样的答案，但这样的答案会让人产生“我已经学会怎么做这题”的错觉。

```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, unsigned int k) {
        ListNode *pAHead = head;
        ListNode *pBehind = nullptr;

        for(unsigned int i=0; i<k-1; i++){
            pAHead = pAHead->next;
        }
        pBehind = head;
        while(pAHead->next != nullptr){
            pAHead = pAHead->next;
            pBehind = pBehind->next;
        }

        return pBehind;
    }
};
```

不少人在面试之前从网上看到这种题解，当面试官问这道题时，他们心中一阵窃喜，很快就能写出代码。可是几天之后他们等来的不是 Offer，却是拒信，于是百思不得其解。其实原因很简单，就是自己写的代码不够鲁棒。以上面的代码为例，虽然能通过 LeetCode，但面试官可以找出 3 种办法让这段代码崩溃：

- 输入 head 为空指针。由于代码会试图访问空指针的内存，程序会崩溃。
- 输入的以 head 为头节点的链表的结点总数小于 k。由于在 for 循环中会在链表上前进 k-1 步，依然会由于空指针导致程序崩溃。
- 输入的参数 k 为 0。由于 k 是一个无符号整数，那么在 for 循环中 k-1 得到的将不是 -1，而是  0xFFFFFFFF。因此执行次数远远超过我们的预计，同样会导致程序崩溃。

这么简单的代码却存在 3 个潜在崩溃的风险，我们可以想想当面试官看到这样的代码时会有怎样的心情，最终他给出的是拒信而不是 Offer 虽然是意料之外但也在情理之中。

## 02 希尔排序为什么需要用 1, 4, 13 这种递增序列？

希尔排序算法的性能不仅取决于 h，还取决于 h 之间的数学性质，比如它们的公因数等。

## 03 希尔排序的原理是什么？

希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。

它更高效的原因是它权衡了**子数组的规模和有序性**。排序之处，各子数组都很短，排序之后子数组都是部分有序。子数组部分有序的程度取决于递增序列的选择。

## 04 希尔排序应用场景？

**有经验的程序员有时会选择希尔排序，因为对于中等大小的数组它的运行时间是可接受的。它的代码量很小，且不需要额外的内存空间。**

如果你需要解决一个排序问题，而又没有系统排序函数可用（直接接触硬件或是运行在嵌入式中），可以先用希尔排序，在考虑是否替换为更复杂的排序算法。

## 05 归并排序的核心思想是什么？

将两个有序的数组合并成一个更大的有序数组——merge 函数。

```c++
void merge(vector<int> &nums, int lo, int mid, int hi){
    int N = nums.size();
    int i=lo, j=mid+1;
    for(int k=lo; k<=hi; k++)
        tmp[k] = nums[k];
    for(int k=lo; k<=hi; k++){
        if(i>mid)               nums[k] = tmp[j++];
        else if(j>hi)           nums[k] = tmp[i++];
        else if(tmp[j]<tmp[i])  nums[k] = tmp[j++];
        else                    nums[k] = tmp[i++];
    }
}
```

- 自顶向下的归并排序：要将一个数组排序，可以先递归地将它分为两半分别排序，然后将结果归并起来。
- 自底向上的归并排序：多次遍历整个数组，将子数组大小进行两两归并。

## 06 归并排序和快速排序的区别？

归并排序将数组分为两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序。

快速排序非常类似归并排序-自顶向下的写法，不过快速排序是拆分，归并排序是合并。

## 07 优先队列的优势？

许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将他们排序。很多情况我们会收集一些元素，然后处理当前键值的最大元素，然后再收集更多的元素，再处理当前键值最大的元素。在这种情况下，一个合适的数据结构的应该支持两种操作：**删除最大的元素和插入元素。**这种数据结构叫做优先队列。

> 优先队列可以使用很小的内存就得到前 k 大的数。



## 08 二叉堆是什么？

二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不适用数组的第一个位置）。简单起见，在下文中我们将二叉堆简称为堆。

**在一个堆中，位置 k 的节点的父节点的位置为 k/2，而它的子节点的位置分别为 2k 和 2k+1**。

这样在不使用指针的情况下，我们也可以通过计算数组的索引在树上下移动：从 a[k] 向上一层就令 k 等于 k/2，向下一层则令 k 等于 2k 或 2k+1。

## 09 堆的有序化是什么？

堆的操作（less 和 swap）会首先进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复，我们称这个过程叫做堆的有序化。

- 上浮（swim）：如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是堆 A 的下浮。
- 下沉（sink）：如果某个节点 A 比它的子节点小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 的下沉。

堆有序化的过程，总是将更大的值放到上方。

## 10 为什么在堆的表示中不使用 a[0]？

这么做可以稍微简化计算。实现从 0 开始的堆并不困难，a[0] 的子节点是 a[1] 和 a[2]，以此类推。但大多数程序员更喜欢我们的简单方法。另外，将 a[0] 的值作为哨兵（作为 a[1] 的父节点）

## 11 堆排序有哪些优缺点？

堆排序是我们所知的唯一能够同时最优利用空间和时间的方法——在最坏情况也能保证使用 ~2NlgN此比较和恒定的存储空间。当空间非常紧张时非常受欢迎。

现代系统的许多应用很少使用它，因为它无法利用缓存。

## 12 堆排序的原理是什么？

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int N = nums.size();
        for(int k=N/2;k>=1; k--){
            sink(nums, k, N);
        }
        while(N>1){
            swap(nums, 1, N--);
            sink(nums, 1, N);
        }
    }
};
```

 从右至左用 sink函数构造子堆，数组的每个位置都已经是一个子堆的根节点，sink 对于这些子堆也适用。如果一个节点的两个子节点都已经是堆了，那么在该节点上调用 sink 可以将它们变成一个堆。这个过程会递归的建立起堆的秩序。

**开始时我们只需要扫描数组中的一半元素，因为我们可以跳过大小 1 的子堆**。最后我们在位置 1 上调用 sink 方法，扫描结束。在排序的第一阶段，堆的构造方法和我们想象的有所不同，因为我们的目标是**构造一个堆有序的数组并使最大元素位于数组的开头而非构造函数。**

然后 while 循环将最大的元素 a[1] 和 a[N] 的位置交换并修复堆，如此重复知道堆变空。

## 13 快速排序的切分 partition 函数是如何工作的？

一般的策略是先随意选取 a[lo] 作为切分元素，即那个将会被排定的元素，然后我们从数组的左端开始向右扫描直到找到一个小于等于它的元素，再从数组的右端开始向左扫描直到找到一个大于等于它的元素。这两个元素显然是没有排定的，因此我们交换它们的位置。

如此继续，我们就可以保证左指针 i 的左侧元素都不大于切分元素，右侧 j 的右侧元素都不小于切分元素。当两个指针相遇时，我们只需要将切分元素 a[0] 和左子数组最右侧的元素 a[j] 交换，然后返回 j 即可。

**为什么返回 j，而不是返回 i？**

```c++
while(true){
    while(nums[++i] < v) if(i==hi) break;
    while(v < nums[--j]) if(j==lo) break;
    if(i>=j) break;
    swap(nums[i], nums[j]);
}
```

在内部有两个循环，分别可以保证 i 左侧的元素都不大于 v，j 右侧的元素都不小于 v。nums[lo] 需要以插入排序的方式插入到数组中，通常需要插入到 j 的位置（j 所在的元素小于 v，把 j 所在的元素前移。前面的元素刚好小于 v，后面的元素刚好大于 v）。

如果替换 i，i 所在的位置大于 v，把 i 所在的元素前移，后面还需要想办法后移。

## 14 快速排序为什么需要使用 shuffle 函数？

在快速排序中，基准元素的选取会影响算法的时间复杂度和稳定性。如果每次都选取第一个或最后一个作为基准元素，那么当数组已经有序或者近乎有序时，算法的效率就会变得非常低。为了避免这种情况，可以采用随机选取元素的方式来选取基准函数。

shuffle 函数可以将数组随机打乱，从而使得基准元素再数组中的位置是随机的。这样处理有序或近乎有序的数组时，每次选取的基准元素都是随机的，从而保证了算法的时间复杂度和稳定性（避免出现最坏情况）。

## 15 堆排序中的 sink 函数是如何工作的？

这个过程和选择排序有些类似（按照降序而非升序取出所有元素），但所需要的比较要少得多。

如果堆的有序状态因为某个节点变得比它的两个子节点或是其中之一更小了而被打破，那么我们可以通过将它和它的子节点中的较大者交换来修复堆。交换可能会在子结点处继续打破堆的有序状态，因此我们需要不断地用相同的方式来将其修复，将节点向下移动直到它的子节点都比它小或是到达了堆底。

```c++
void sink(vector<int> &nums, int k, int N){	
    while(2*k <= N){	// 存在子节点
        int j=2*k;
        if(j<N && nums[j+1] > nums[j])  j++;	// 左子节点不是最后一个节点 && 右子节点大于左子节点
        if(nums[k] > nums[j])           break;	// 父节点大于子节点
        swap(nums[k], nums[j]);					// 交换父子节点
        k = j;									// 更新 k，继续查看子节点是否需要 sink。
    }
}
```